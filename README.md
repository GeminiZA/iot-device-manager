# iot-device-manager

Device manager RESTful API server written for a project. Please see notes at the end

## Setup

### Server Setup

#### Locally

- clone the repository
- create `.env` see [example](.env.example) in root directory of the repository
- run `go build .`
- run `./iot-device-manager`

#### Docker-Compose

- clone the repository
- create `.env` see [example](.env.example) in root directory of the repository
  - The following should be omitted and rather specified the in `docker-compose` command for the docker setup:
  - MQTT_BROKER_PORT
  - MQTT_BROKER_WS_PORT
  - API_PORT
- Create `config.yaml` in `startMochi/` (see **config.yaml**) below
- Add users needed for devices and server in the config file
- run `docker-compose up -d` or `MQTT_BROKER_PORT=1883 MQTT_BROKER_WD_PORT=8000 API_PORT=8080 docker-compose up -d` (defaults) to specify the ports to be used
- run `docker logs iot-device-manager` to ensure everything is started correctly

### Standalone Mochi Setup

- Create `config.yaml` in `startMochi/`
- Add users needed for devices and server
- run docker-compose up -d
- will always restart on unexpected shutdown

#### config.yaml

The specified ports in listeners should match the ports provided in the environment variables set for the iot-device-manager

```
listeners:
  - type: "tcp"
    id: "mqtt"
    address: ":1883"
  - type: "ws"
    id: "mqtt-ws"
    address: ":8000"

hooks:
  auth:
    ledger:
      auth:
        - username: "[username]"
          password: "[password]"
          allow: true
        - username: "[username]"
          password: "[password]"
          allow: true
```

# Usage

## Devices

Devices are references by `id` which is a _uint_ and need to be added to the server by the http endpoint before the server will keep track of its status and telemetry

## MQTT

All assets updates, telemetry and commands are published to `assets/:id`

MQTT username and password must match that defined in `mochi-mqtt/config.yaml`

update messages are _json_ and of the following forms:

#### Telemetry

Message publishing telemetry data and status from the device

```
{
  "status": string,
  "telemetry": object
}
```

#### Update

Message publishing an update to the device name and status

```
{
  "status": string,
  "name": string
}
```

#### Command

Message publishing a command to the device name and status

```
{
  "command": string
}
```

only `stop` and `start` commands are currently supported and determines whether the device is publishes its telemetry data or not

#### Notes

Status is a string to allow extension on its functionality

Telemetry is a json object to allow any sort of data to stored in it regardless of what device needs to publish

## HTTP

### Endpoints

#### GET (/assets/:id)

Returns the asset details including telemetry as _json_:

- Name
- Status
- Telemetry

```
{
  "name": string,
  "status": string,
  "telemetry": [
    {
      timestamp: string,
      telemetry: object # object allows any data to be stored
    },
    ...
  ]
}
```

#### POST (/assets)

Creates a new device, subscribes to the relevant MQTT topic and publishes a `start` command to the relevant MQTT topic

Request body:

```
{
  "name": string,
  "id": int
}
```

id must be a _positive 32 bit integer_ and must be unique

Returns as _json_:

- Name
- ID

```
{
  "name": string,
  "id": int
}
```

Notes:

The id should ideally be generated by the server to ensure no conflicts then returned to the device, the id is required in the request body to adhere to the middleware requirement in the provided requirements

#### PUT (/assets/:id)

Updates the details of the device the database and publishes the update to the relevant MQTT topic

Request body:

```
{
  "status": string,
  "name": string
}
```

Returns only a status code

#### DELETE (/assets/:id)

Deletes the device from the database, publishes a `stop` command to the device's MQTT topic and subsequently disallows updates to that device from the MQTT broker

No Request Body

Returns only a status code

# Notes

I had to make some assumptions with the requirements that necessitated some compromises in the implementation of the project.

- The ID of the device is determined before its registration on the api as middleware to validate a unique id was specified in the requirements. This means that the ID can be non unique when attempting to add it but it is enforced in the database and middleware that it is unique. Therefore any device that needs to be registered but has a non unique ID will not be able to be registered
- Telemetry can be any data in json form, this is then stored in a timeseries and all parsing will have to be handled by the frontend
- All telemetry data is received via MQTT and the http endpoints are only for changing the details such as the device name and retrieving the data

No authentication or authorization has been implemented as it was not included in the requirements. This includes the MQTT broker which for now just uses usernames and passwords which need to be set manually and would need to be manually set on each device

The status string for the assets can be changed to display the status of the device if necessary, for now it is just online or offline (if it has not published any updates in the past 30 seconds)

Commands, status updates and telemetry are all published on the same MQTT topic, this is suboptimal and will need to be changed

I have not implemented the embedded integration as I do not currently have access to device that is sufficient for this. Instead I implemented a test application to mock many devices at once, see [mock-iot-device](https://github.com/GeminiZA/mock-iot-device)

I used Next.js for the frontend demonstration of the data with real-time updates as create-next-app has been deprecated. It has not been deployed anywhere yet. It can for now be run locally. See [iot-device-manager](https://github.com/GeminiZA/iot-device-manager)

I used json for the encoding of the MQTT messages to simplify implementation, I would have preferred to use bEncode or define my own encoding schema that would be more space efficient
